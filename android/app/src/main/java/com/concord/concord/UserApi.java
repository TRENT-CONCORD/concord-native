// Autogenerated from Pigeon (v24.2.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package com.concord.concord;

import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.CLASS;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import io.flutter.plugin.common.BasicMessageChannel;
import io.flutter.plugin.common.BinaryMessenger;
import io.flutter.plugin.common.MessageCodec;
import io.flutter.plugin.common.StandardMessageCodec;
import java.io.ByteArrayOutputStream;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/** Generated class from Pigeon. */
@SuppressWarnings({"unused", "unchecked", "CodeBlock2Expr", "RedundantSuppression", "serial"})

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
public interface UserApi {

  @NonNull 
  UserDetails getUserDetails();

  /** The codec used by UserApi. */
  static @NonNull MessageCodec<Object> getCodec() {
    return PigeonCodec.INSTANCE;
  }

  /**Sets up an instance of `UserApi` to handle messages through the `binaryMessenger`. */
  static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable UserApi api) {
    setUp(binaryMessenger, "", api);
  }

  static void setUp(@NonNull BinaryMessenger binaryMessenger, @NonNull String messageChannelSuffix, @Nullable UserApi api) {
    messageChannelSuffix = messageChannelSuffix.isEmpty() ? "" : "." + messageChannelSuffix;
    {
      BasicMessageChannel<Object> channel =
          new BasicMessageChannel<>(
              binaryMessenger, "dev.flutter.pigeon.concord.UserApi.getUserDetails" + messageChannelSuffix, getCodec());
      if (api != null) {
        channel.setMessageHandler(
            (message, reply) -> {
              ArrayList<Object> wrapped = new ArrayList<>();
              try {
                UserDetails output = api.getUserDetails();
                Log.d("UserApi", "getUserDetails returned: " + output.toList());
                wrapped.add(0, output.toList());
              } catch (Throwable exception) {
                wrapped = Helper.wrapError(exception);
              }
              reply.reply(wrapped);
            });
      } else {
        channel.setMessageHandler(null);
      }
    }
  }

  /** Helper class for error handling. */
  class Helper {
    /** Error class for passing custom error details to Flutter via a thrown PlatformException. */
    public static class FlutterError extends RuntimeException {

      /** The error code. */
      public final String code;

      /** The error details. Must be a datatype supported by the api codec. */
      public final Object details;

      public FlutterError(@NonNull String code, @Nullable String message, @Nullable Object details) {
        super(message);
        this.code = code;
        this.details = details;
      }
    }

    @NonNull
    protected static ArrayList<Object> wrapError(@NonNull Throwable exception) {
      ArrayList<Object> errorList = new ArrayList<>(3);
      if (exception instanceof FlutterError) {
        FlutterError error = (FlutterError) exception;
        errorList.add(error.code);
        errorList.add(error.getMessage());
        errorList.add(error.details);
      } else {
        errorList.add(exception.toString());
        errorList.add(exception.getClass().getSimpleName());
        errorList.add(
          "Cause: " + exception.getCause() + ", Stacktrace: " + Log.getStackTraceString(exception));
      }
      return errorList;
    }
  }
}

@Target(METHOD)
@Retention(CLASS)
@interface CanIgnoreReturnValue {}

/** Generated class from Pigeon that represents data sent in messages. */

class PigeonCodec extends StandardMessageCodec {
  public static final PigeonCodec INSTANCE = new PigeonCodec();

  private PigeonCodec() {}

  @Override
  protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
    switch (type) {
      case (byte) 129:
        Object rawData = readValue(buffer);
        Log.d("PigeonCodec", "Decoding raw data: " + rawData.toString());
        return UserDetails.fromList((ArrayList<Object>) rawData);
      default:
        return super.readValueOfType(type, buffer);
    }
  }

  @Override
  protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
    if (value instanceof UserDetails) {
      Log.d("PigeonCodec", "Encoding UserDetails: " + ((UserDetails) value).toList());
      Log.d("PigeonCodec", "Encoded data structure: " + ((UserDetails) value).toList().toString());
      stream.write(129);
      writeValue(stream, ((UserDetails) value).toList());
    } else {
      super.writeValue(stream, value);
    }
  }
}
